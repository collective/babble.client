/*
GNU General Public License (GPL)

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
02110-1301, USA.
*/

var SUCCESS = 0;
var AUTH_FAIL = -1;
var TIMEOUT = 1;
var SERVER_FAULT = 2;

var blink_order = 0;
var doc_title;
var messages_found = 0;
var poll_count = 0;         // The amount of server polls that have been made
var poll_cycle = 10;        // The amount of polls to make in a cycle

//TODO:
// We should refactor the DTML statements to rather fetch these variables from
// the DOM.
//
// This will allow us to use jUnit to do unit testing.
<dtml-let pollmax="portal_chat.poll_max">
var poll_max = &dtml-pollmax;;  // The maximum polling period
</dtml-let>

<dtml-let pollmin="portal_chat.poll_min">
var poll_min = &dtml-pollmin;;  // The minimum polling period
</dtml-let>

<dtml-let member="portal_membership.getAuthenticatedMember().getId().encode('utf-8')">
var username = "&dtml-member;";
</dtml-let>

<dtml-let baseurl="portal_url()">
var base_url = "&dtml-baseurl;";
</dtml-let>

var timeout = 2000;
var poll_interval = poll_min;   // The initial polling period

var window_focus = true;
var chat_focus = new Array();
var new_chats = new Array();
var chats = new Array();    // Records new chat windows being opened. 

var global_received_date = '0001-01-01T00:00:00+00:00';
var sent_since_date = [];

if (!log) {
var log = {
    toggle: function() {},
    move:   function() {},
    resize: function() {},
    clear:  function() {},
    debug:  function() {},
    info:   function() {},
    warn:   function() {},
    error:  function() {},
    profile: function() {}
};
}

function prep4JQ(str) {
    /* From JQUERY selector docs: 
    * If you wish to use any of the meta-characters 
    * (#;&,.+*~':"!^$[]()=>|/@ ) as a literal part of a name, 
    * you must escape the character with two backslashes: \\.
    */
    str = str.replace(/\#/g, '\\#');
    str = str.replace(/\;/g, '\\;');
    str = str.replace(/\&/g, '\\&');
    str = str.replace(/\,/g, '\\,');
    str = str.replace(/\./g, '\\.');
    str = str.replace(/\+/g, '\\+');
    str = str.replace(/\*/g, '\\*');
    str = str.replace(/\~/g, '\\~');
    str = str.replace(/\'/g, "\\'");
    str = str.replace(/\:/g, '\\:');
    str = str.replace(/\"/g, '\\"');
    str = str.replace(/\!/g, '\\!');
    str = str.replace(/\^/g, '\\^');
    str = str.replace(/\$/g, '\\$');
    str = str.replace(/\[/g, '\\[');
    str = str.replace(/\]/g, '\\]');
    str = str.replace(/\(/g, '\\(');
    str = str.replace(/\)/g, '\\)');
    str = str.replace(/\=/g, '\\=');
    str = str.replace(/\>/g, '\\>');
    str = str.replace(/\|/g, '\\|');
    str = str.replace(/\//g, '\\/');
    str = str.replace(/\@/g, '\\@');
    return str
}

function getMinimizedChats() {
    var cookie = jQuery.cookie('chats_minimized_'+username);
    if (cookie)
        return cookie.split(/\|/);
    return []
}

function sanitizePath(call) {
    return base_url + call
}

function oc(a) {
    // Thanks to Jonathan Snook: http://snook.ca
    var o = {};
    for(var i=0; i<a.length; i++) {
        o[a[i]]='';
    }
    return o;
}

jQuery(document).ready(function() {
    if (init()) { 
        jQuery.doTimeout(poll_max, function() {
            init();
        });
    }
});

function init() {  
    if (!username)
        return true; // This will let doTimout continue, i.e init will be called again.

    var open_chats = [];
    var cookie = jQuery.cookie('chats-open-'+username);
    log.info('init: cookie = ' + cookie + '\n');
    jQuery.cookie('chats-open-'+username, null, {path: '/'});
    if (cookie) {
        open_chats = cookie.split('|');
        for (var i=0; i<open_chats.length; i++) {
            var chat_id = open_chats[i];
            if (chat_id) { 
                createChat(chat_id, 1);
            }
        }
    }
    path = sanitizePath('/@@babblechat/initialize')
    jQuery.ajax({
        url: path,
        cache: false,
        dataType: "json",
        timeout: timeout,
        error: function (XMLHttpRequest, textStatus, errorThrown) {
            log.error('init: ' + textStatus);
            log.error('init: ' + errorThrown);
            // This will let doTimout continue, i.e init will be called again.
            return true; 
        },
        success: function(data) {
            if (Number(data.status) == TIMEOUT) {
                // This will let doTimout continue, i.e init will be called again.
                log.warn('init: TIMEOUT');
                return true; 
            }
            else if (Number(data.status) == AUTH_FAIL) {
                log.warn('init: AUTH_FAIL');
                return false;
            }
            log.info('init: Success!');
            poll_interval = poll_min;
            poll_count = 0
            poll();
        }
    });
}

function appendMessages(chat_id, contact_id, fullname, messages, minimized, clear_and_replace) {
    /*  chat_id:    The id attr of the chatbox 
        contact_id: The contact_id of the conversation partner or chatroom
        fullname:   The fullname of the conversation partner
        minimized:  Should the chatbox be minmized?
        clear_and_replace: Clear and replace all messages that might be in the chatbox (if it exists).
    */
    log.info('appendMessages: contact_id is ' + contact_id)
    messages_found += 1;
    if (!new_chats)
        new_chats = [];

    new_chats[chat_id] = true;
    var chat = jQuery('#'+prep4JQ(chat_id));
    if (chat.length <= 0) {
        createChat(chat_id, minimized);
        // createChat will fetch all uncleared messages (including the new ones
        // we have here), therefore we can just return here
        return
    }
    if (chat.css('display') == 'none') {
        chat.css('display','block');
        reorderChats();
    }
    var chat_content = chat.find(".chat-content");
    if (clear_and_replace) {
        chat_content.empty()
    }
    for (var i=0; i<messages.length; i++) {
        //  XXX: Need to put in the full date if more than a day ago...
        message = messages[i];
        var text = message[1];
        var year = message[2].substring(0,4);
        var month = message[2].substring(5,7);
        var day = message[2].substring(8,10);
        var hour = message[2].substring(11,13);
        var minute = message[2].substring(14,16);
        var timeob = new Date(new Date(year, month, day, hour, minute) - new Date().getTimezoneOffset() * 60000);
        var localtime = timeob.toLocaleTimeString().substring(0,5);
        if (message[0] == contact_id) {
            message_html = '<div class="chat-message">' + 
                                '<span class="chat-message-them">'+fullname+' '+localtime+':&nbsp;&nbsp;</span>' + 
                                '<span class="chat-message-content">'+text+'</span>' + 
                            '</div>'
        }
        else if (messages[i][2] in oc(sent_since_date)) {
            continue
        } 
        else {
            message_html = '<div class="chat-message">' + 
                                '<span class="chat-message-me">me '+localtime+':&nbsp;&nbsp;</span>' + 
                                '<span class="chat-message-content">'+text+'</span>' + 
                            '</div>'
        }
        chat_content.append(message_html);
    }
    chat_content.scrollTop(chat_content[0].scrollHeight);
}

function reorderChats() {
    var index = 0;
    for (var i=0; i < chats.length; i++) {
        var chatbox =  jQuery("#"+prep4JQ(chats[i]));
        if (chatbox.css('display') != 'none') {
            if (index == 0) {
                chatbox.css('right', '20px');
            } 
            else {
                width = (index)*(225+7)+20;
                chatbox.css('right', width+'px');
            }
            index++;
        }
    }
}

function positionNewChat(chatbox) {
    var open_chats = 0;
    for (var i=0; i<chats.length; i++) {
        if (jQuery("#"+prep4JQ(chats[i])).css('display') != 'none') {
            open_chats++;
        }
    }
    if (open_chats == 0) {
        chatbox.css('right', '20px');
    } 
    else {
        width = (open_chats)*(225+7)+20;
        chatbox.css('right', width+'px');
    }
    // reorderChats();
}

function closeChat(chat_id, contact) {
    jQuery('#'+prep4JQ(chat_id)).css('display','none');
    reorderChats();
    var cookie = jQuery.cookie('chats-open-'+username);
    if (cookie)
        var open_chats = cookie.split('|');
    else
        var open_chats = [];

    new_chats = Array();
    for (var i=0; i < open_chats.length; i++) {
        if (open_chats[i] != chat_id) {
            new_chats.push(open_chats[i]);
        }
    }
    log.info('closeChat: cookie \n');
    if (new_chats.length) {
        jQuery.cookie('chats-open-'+username, new_chats.join('|'), {path: '/'});
    }
    else {
        jQuery.cookie('chats-open-'+username, null, {path: '/'});
    }
    path = sanitizePath('/@@babblechat/clear_messages');
    jQuery.ajax({
        url: path,
        cache: false,
        data: {contact: contact, until: global_received_date },
        error: function (XMLHttpRequest, textStatus, errorThrown) {
            log.error(textStatus);
            log.error(errorThrown);
        },
        success: function() {
            log.info(chat_id + "'s messages succesfully cleared. \n");
        }
    });
}

function createChat(chat_id, minimize) {
    log.info('createChat: chat_id is ' + chat_id)
    var cookie = jQuery.cookie('chats-open-'+username);
    log.info('createChat: cookie is ' + cookie)
    if (cookie)
        var open_chats = cookie.split('|');
    else
        var open_chats = [];

    if (!(chat_id in oc(open_chats))) {
        // Update the cookie if this new chat is not yet in it.
        open_chats.push(chat_id);
        var new_cookie = open_chats.join('|');
        jQuery.cookie('chats-open-'+username, new_cookie, {path: '/'});
        log.info('createChat: updated cookie = ' + new_cookie + '\n');
    }

    var chatbox = jQuery("#"+prep4JQ(chat_id));
    if (chatbox.length > 0) {
        // The chatbox exists, merely hidden
        if (chatbox.css('display') == 'none') {
            chatbox.css('display','block');
            reorderChats();
        }
        chatbox.find(".chat-textarea").focus();
        return;
    }
    chatbox = createChatBox(chat_id);
    positionNewChat(chatbox);
    chats.push(chat_id);
    if (minimize == 1) {
        // Minimize the chat if it's in the minimized_chats cookie
        var minimized_chats = getMinimizedChats();
        if (chat_id in oc(minimized_chats)) {
            chatbox.find('.chat-content').css('display','none');
            chatbox.find('.chat-input').css('display','none');
        }
    }
    handleChatEvents(chat_id)
    chatbox.show();
    var chat_content = chatbox.find('.chat-content');
    chat_content.scrollTop(chat_content[0].scrollHeight);
}

function startChat(chat_id) {
    createChat(chat_id, 0);
    jQuery("#"+prep4JQ(chat_id)+" .chat-textarea").focus();
    // Reset the polling
    messages_found = 0;
    poll_count = 0;
    poll_interval = poll_min;
    poll();
}

function createChatBox(chat_id) {
    var path = sanitizePath('/@@render_chat_box');
    jQuery.ajax({
        url: path,
        cache: false,
        async: false,
        data: {
            box_id: chat_id,
        },
        error: function (XMLHttpRequest, textStatus, errorThrown) {
            log.error(textStatus);
            log.error(errorThrown);
            return
        },
        success: function(data) {
            jQuery('body').append(data).find('.chat-message .time').each(function (){
                jthis = jQuery(this);
                var time = jthis.text().split(':');
                var hour = time[0];
                var minutes = time[1];
                var date = new Date();
                date.setHours(hour - date.getTimezoneOffset() / 60);
                date.setMinutes(minutes);
                jthis.replaceWith(date.toLocaleTimeString().substring(0,5));
            })
            var last_msg_date = jQuery('div#'+chat_id).attr('last_msg_date');
            if ((last_msg_date != undefined)&&(last_msg_date > global_received_date)) {
                global_received_date = last_msg_date;
                sent_since_date = [];
            }
        }
    });
    return jQuery('#'+prep4JQ(chat_id));
}

function handleChatEvents(chat_id) {
    chat_focus[chat_id] = false;
    var chat_area = jQuery("#"+prep4JQ(chat_id)+" .chat-textarea");
    chat_area.blur(function(){
        chat_focus[chat_id] = false;
        chat_area.removeClass('chat-textarea-selected');
    }).focus(function(){
        chat_focus[chat_id] = true;
        chat_area.addClass('chat-textarea-selected');
    });
    var chatbox = jQuery("#"+prep4JQ(chat_id));
    chatbox.click(function() {
        if (chatbox.find('.chat-content').css('display') != 'none') {
            chatbox.find('.chat-textarea').focus();
        }
    });
}

function poll() {
    /* The way doTimout works, it will execute the code in the callback
     * function *after* poll_interval has passed. */
    log.info('poll: poll_interval = '+ poll_interval);
    jQuery.doTimeout('message_poll', poll_interval, function(){
        poll_server();
        if (messages_found > 0) {
            // Reset the poll
            log.info('resetting the poll');
            messages_found = 0;
            poll_count = 0;
            poll_interval = poll_min;
            poll();
            return
        } 
        poll_count++;
        if (poll_count >= poll_cycle) { 
            if (poll_interval < poll_max)
                poll_interval *= 2;
                
            if (poll_interval > poll_max)
                poll_interval = poll_max;

            // Reset the poll
            poll_count = 0;
            poll();
            return
        }
        return true;
    });
}

function poll_server() {
    path = sanitizePath('/@@babblechat/poll');
    jQuery.ajax({
        url: path,
        cache: false,
        async: true,
        timeout: timeout,
        dataType: "json",
        data: {username: username}, 
        error: function (XMLHttpRequest, textStatus, errorThrown) {
            log.error('poll_server: ' + textStatus);
            log.error('poll_server: ' + errorThrown);
        },
        success: function(data) {
            if (Number(data.status)  == TIMEOUT) {
                // When the server times out while fetching messages, we have
                // to call init again, to get all uncleared_messages,
                // otherwise we might lose some messages that might have been
                // marked as read by the timed out process!

                // First, we have to cancel the existing poll, without
                // executing it's callback
                log.warn('poll_server: TIMEOUT');
                jQuery.doTimeout('message_poll');

                // No we start a poll calling getUnclearedMessages.
                // getUnclearedMessages will determine wether this poll will
                // call again, or whether it will be replaced with the default
                // message_poll.
                jQuery.doTimeout('message_recovery_poll', poll_interval, function() {
                    getUnclearedMessages();
                });
            }
            for (var contact_id in data.messages) {
                var messages = data.messages[contact_id][1];
                if (!messages.length) 
                    continue
                var fullname = data.messages[contact_id][0];
                log.info('We received messages for contact_id: ' + fullname);
                var chat_id = 'chatbox'+'_'+chatroom_id;
                appendMessages(chat_id, contact_id, fullname, messages, 0, 0);
            };
            for (var chatroom_id in data.chatroom_messages) {
                var chatroom_messages = data.chatroom_messages[chatroom_id][1];
                if (!messages.length) 
                    continue
                var title = data.chatroom_messages[chatroom_id][0];
                log.info('We received messages for chatroom: ' + title);
                var chat_id = 'chatroom'+'_'+chatroom_id;
                appendMessages(chat_id, chatroom_id, title, chatroom_messages, 0, 0);
            };
            if (data.last_msg_date > global_received_date)  {
                global_received_date = data.last_msg_date;
                sent_since_date = [];
            }
        }
    });
}

function getUnclearedMessages() {
    /* If poll() times out, then we will have to call this method instead to
     *  get all uncleared messages, to avoid losing messages that were marked as
     *  read during the timed out process. */
    log.info('getUnclearedMessages');
    path = sanitizePath('/@@babblechat/get_uncleared_messages');
    jQuery.ajax({
        url: path,
        cache: false,
        async: true,
        error: function (XMLHttpRequest, textStatus, errorThrown) {
            log.error(textStatus);
            log.error(errorThrown);
            // This will let doTimout continue, i.e get_uncleared_messages will be called again.
            return true; 
        },
        success: function(data) {
            if (Number(data.status) == TIMEOUT) {
                // This will let doTimout continue, i.e get_uncleared_messages will be called again.
                return true; 
            }
            for(var contact_id in data.messages) {
                var messages = data.messages[contact_id][1];
                if (!messages.length) 
                    continue
                var tuple = data.messages[contact_id]
                var fullname = data.messages[contact_id][0];
                var chat_id = 'chatbox'+'_'+contact_id;
                appendMessages(chat_id, contact_id, fullname, messages, 0, 1);
            };
            for(var chatroom_id in data.chatroom_messages) {
                var messages = data.messages[chatroom_id][1];
                if (!messages.length) 
                    continue
                var tuple = data.messages[chatroom_id]
                var title = data.messages[chatroom_id][0];
                var chat_id = 'chatroom'+'_'+chatroom_id;
                appendMessages(chat_id, chatroom_id, title, messages, 0, 1);
            };

            // Cancel the current poll
            jQuery.doTimeout('message_recovery_poll');
            // Now call the normal poll again
            poll_interval = poll_min;
            poll_count = 0
            poll();
        }
    });
}

function keypressed(event, textarea, contact_id, last_msg_date, chat_id) {
	if(event.keyCode == 13 && event.shiftKey == 0) {
        var textbox = jQuery(textarea);
		var message = textbox.val();
		message = message.replace(/^\s+|\s+jQuery/g,"");
		textbox.val('').focus().css('height','44px');
		if (message != '') {
            path = sanitizePath('/@@babblechat/send_message');
            jQuery.ajax({
                url: path,
                cache: false,
                async: true,
                dataType: "json",
                data: {to: contact_id, message: message}, 
                error: function (XMLHttpRequest, textStatus, errorThrown) {
                    log.error(textStatus);
                    if (errorThrown)
                        log.error(errorThrown)

                    var chat_content = jQuery('#'+prep4JQ(chat_id)+' .chat-content');
                    chat_content.append(
                        '<div class="chat-message">' + 
                            '<span class="chat-message-error">Connection Error</span>' + 
                        '</div>');
                    chat_content.scrollTop(chat_content[0].scrollHeight);
                },
                success: function(data) { 
                    log.info("Message succesfully sent. \n");
                    sent_since_date = sent_since_date.concat([data.last_msg_date]);

                    message = message.replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/\"/g,"&quot;");
                    list = message.match(/\b(http:\/\/www\.\S+\.\w+|www\.\S+\.\w+|http:\/\/(?=[^w]){3}\S+[\.:]\S+)[^ ]+\b/g);
                    if (list) {
                        for (i = 0; i < list.length; i++) {
                            message = message.replace( list[i], "<a target='_blank' href='" + escape( list[i] ) + "'>"+ list[i] + "</a>" );
                        }
                    }
                    var now = new Date();
                    var minutes = now.getMinutes().toString();
                    if (minutes.length==1) {minutes = '0'+minutes;}
                    var time = now.toLocaleTimeString().substring(0,5);
                    var chat_content = jQuery('#'+prep4JQ(chat_id)+' .chat-content');
                    chat_content.append(
                        '<div class="chat-message">' + 
                            '<span class="chat-message-me">me '+time+':&nbsp;&nbsp;</span>' + 
                            '<span class="chat-message-content">'+message+'</span>' + 
                        '</div>');
                    chat_content.scrollTop(chat_content[0].scrollHeight);

                    poll_interval = poll_min;
                    poll_count = 0
                    poll(); // Calling poll, cancels the existing poll and replaces it with a new one 
                            // (with the updated poll values)
                }
            });
		}
	}
	var adjustedHeight = textarea.clientHeight;
	var maxHeight = 94;
	if (maxHeight > adjustedHeight) {
		adjustedHeight = Math.max(textarea.scrollHeight, adjustedHeight);
		if (maxHeight)
			adjustedHeight = Math.min(maxHeight, adjustedHeight);
		if (adjustedHeight > textarea.clientHeight)
			jQuery(textarea).css('height',adjustedHeight+8 +'px');
	} 
    else {
		jQuery(textarea).css('overflow','auto');
	}
}

function toggleChat(chat_id) {
    var minimized_chats = getMinimizedChats();
    if (jQuery('#'+prep4JQ(box_id)+' .chat-content').css('display') == 'none') {  
        // Chat will be maximized
        var new_cookie = Array();
        for (var i=0; i < minimized_chats.length; i++) {
            if (minimized_chats[i] != chat_id) {
                new_cookie.push(minimized_chats[i]);
            }
        }
        jQuery.cookie('chats_minimized_'+usergc, new_cookie.join('|'));
        var chat_content = jQuery('#'+prep4JQ(chat_id)+' .chat-content');
        chat_content.css('display','block');
        chat_content.scrollTop(chat_content[0].scrollHeight);
        jQuery('#'+prep4JQ(chat_id)+' .chat-input').css('display','block');
    } 
    else {
        // Chat will be minimized
        if (!(chat_id in oc(minimized_chats))) {
            var new_cookie = chat_id;
            new_cookie += '|'+minimized_chats.join('|');
            jQuery.cookie('chats_minimized_'+usergc, new_cookie);
        }
        jQuery('#'+prep4JQ(chat_id)+' .chat-content').css('display','none');
        jQuery('#'+prep4JQ(chat_id)+' .chat-input').css('display','none');
    }
}

